# 开卡逻辑对比分析报告

> **分析时间**：2025-12-24  
> **分析目的**：对比现有开卡逻辑与新 API 接口的匹配情况

---

## 📊 总体评估

| 项目           | 现有实现    | 新接口要求  | 匹配状态        |
| -------------- | ----------- | ----------- | --------------- |
| 开卡费配置获取 | ❌ 硬编码   | ✅ 动态 API | 🔴 **不匹配**   |
| 优惠券系统     | ⚠️ 部分实现 | ✅ 完整 API | 🟡 **部分匹配** |
| 支付币种选择   | ❌ 缺失     | ✅ 动态 API | 🔴 **不匹配**   |
| 支付流程       | ❌ 未实现   | ✅ 完整流程 | 🔴 **不匹配**   |
| KYC 资格检查   | ⚠️ 基础查询 | ✅ 支付验证 | 🟡 **部分匹配** |

---

## 🔍 详细逻辑对比

### 1️⃣ 开卡申请流程

#### 现有实现（`CardApplyConfirmScreen.dart`）

```
用户点击申请
  ↓
显示卡信息（硬编码）
  ├─ 卡名称: "Come Come Pay Card"
  ├─ 卡组织: "VISA"
  └─ 卡费: "5 USD" (硬编码)
  ↓
选择网络（用于支付的币种）
  └─ 使用 TokenReceiveViewModel 获取币种列表
  ↓
点击提交 → 直接跳转到 KYC 填资料页面
```

**❌ 问题点**：

1. **卡费硬编码**：代码中写死了 `5 USD`，没有调用 API
2. **没有优惠券选择**：虽然 `CardApplyScreen` 有优惠券 UI，但未实现选择逻辑
3. **没有创建支付订单**：直接跳转到 KYC，跳过了支付流程
4. **网络选择目的不明**：选择的网络地址没有用于后续支付

---

#### 新接口要求的流程

```
1. 获取开卡费配置
   GET /api/v1/CardFee/GetConfig?card_type=virtual
   └─ 返回: fee_amount, fee_type, description

2. 获取支付币种列表
   GET /api/v1/CardFee/GetCurrencies
   └─ 返回: USDT-TRC20, USDT-ERC20, USDC-TRC20 等

3. (可选) 用户选择优惠券
   └─ 优惠券系统已有基础实现

4. 创建支付订单
   POST /api/v1/CardFee/CreatePayment
   Body: { card_type, coupon_code }
   └─ 返回: transaction_ref (交易参考号)

5. 用户选择支付币种

6. 完成支付
   POST /api/v1/CardFee/CompletePayment/:transaction_ref
   Body: { payment_currency }
   └─ 从用户钱包扣款

7. 检查资格
   GET /api/v1/kyc/eligibility
   └─ 确认支付完成，可以进行 KYC

8. 进入 KYC 流程
```

**✅ 优势**：

- 开卡费动态配置，后台可调整
- 支持多种稳定币支付
- 完整的支付记录和状态跟踪
- 优惠券系统可降低用户成本

---

### 2️⃣ 优惠券系统

#### 现有实现

**✅ 已实现部分**：

- `CouponViewModel` - 完整的优惠券 ViewModel
- `GlobalService.getMyCoupons()` - 获取用户优惠券列表
- `GlobalService.claimCoupon()` - 领取优惠券
- `AvailableCouponTab` - 可用优惠券列表 UI
- `CouponDetailModel` - 优惠券详情模型（包含 `code` 字段）

**❌ 缺失部分**：

1. **优惠券选择逻辑**：

   - `CardApplyScreen` 第 54 行有优惠券点击事件，但是空实现
   - 没有弹窗让用户选择可用优惠券
   - 没有保存用户选择的优惠券

2. **优惠券传递**：
   - 创建支付时需要传递 `coupon_code`（优惠券码，不是 ID）
   - 现有的 `CouponModel` 里包含 `coupon.code`，可以直接使用

---

#### 新接口要求

```dart
// 创建支付时传入优惠券码
POST /api/v1/CardFee/CreatePayment
{
  "card_type": "virtual",
  "coupon_code": "CPC59BAW69"  // ← 使用 coupon.code
}

// 返回会显示优惠后的价格
{
  "original_fee": 5,
  "coupon_discount": 1,     // 优惠金额
  "actual_payment": 4,       // 实际支付
  "transaction_ref": "CFP..."
}
```

**🔧 需要实现**：

1. 在开卡申请页面添加"选择优惠券"功能
2. 弹出可用优惠券列表（复用 `AvailableCouponTab` 逻辑）
3. 保存用户选择的 `coupon.code`
4. 在创建支付时传递该优惠券码

---

### 3️⃣ 支付币种选择

#### 现有实现

在 `CardApplyConfirmScreen.dart` 中：

```dart
// 第 74 行：选择网络（Network Selection）
_buildNetworkSelectionRow(viewModel)

// 使用 TokenReceiveViewModel.filteredTokens
// 获取所有币种：BTC, ETH, USDT, USDC 等
```

**⚠️ 问题**：

1. **用途混淆**：
   - 这个"网络选择"是为了获取收款地址
   - 但新接口的支付是从**用户钱包扣款**，不需要地址
2. **币种范围不对**：
   - 支付只支持：USDT-TRC20, USDT-ERC20, USDC-TRC20, USDC-ERC20
   - 当前显示所有币种（包括 BTC, ETH 等非稳定币）

---

#### 新接口要求

```
1. 获取支付币种
   GET /api/v1/CardFee/GetCurrencies
   返回：
   [
     { "name": "USDT-TRC20", "symbol": "USDT", ... },
     { "name": "USDT-ERC20", "symbol": "USDT", ... },
     { "name": "USDC-TRC20", "symbol": "USDC", ... }
   ]

2. 用户选择一个币种

3. 完成支付时传入币种名称
   POST /api/v1/CardFee/CompletePayment/:ref
   { "payment_currency": "USDT-TRC20" }

4. 系统从用户对应币种的钱包余额扣款（1:1等值）
```

**🔧 需要改造**：

1. 创建新的 Service 方法：`getSupportedPaymentCurrencies()`
2. 在支付确认页面显示：
   - 用户各币种的余额
   - 只显示支付支持的币种
   - 余额不足的币种置灰/不可选
3. 保存用户选择的币种（`name` 字段，如 `"USDT-TRC20"`）

---

### 4️⃣ 支付流程

#### 现有实现

```dart
// CardApplyConfirmScreen.dart 第 84-101 行
onPressed: () {
  // TODO: 将选择的网络地址发送到后端
  final networkAddress = _selectedNetwork!['address'] ?? 'mock_address';

  // 直接跳转到 KYC 填资料页面
  Navigator.push(
    context,
    MaterialPageRoute(
      builder: (context) => const Cardverificationscreen(),
    ),
  );
}
```

**❌ 完全缺失**：

- 没有调用创建支付接口
- 没有调用完成支付接口
- 没有检查用户余额是否足够
- 没有支付成功/失败的提示

---

#### 新接口要求的完整流程

```dart
// 伪代码示例

// 步骤1: 用户点击提交按钮
async onSubmit() {
  // 1.1 创建支付订单
  final paymentResponse = await cardFeeService.createPayment(
    cardType: 'virtual',
    couponCode: selectedCoupon?.code,  // 可选
  );

  final transactionRef = paymentResponse.transactionRef;
  final actualPayment = paymentResponse.actualPayment;  // 实际需要支付的金额

  // 1.2 显示支付确认弹窗
  showPaymentConfirmDialog(
    amount: actualPayment,
    currency: selectedCurrency,  // 如 "USDT-TRC20"
  );
}

// 步骤2: 用户确认支付
async confirmPayment() {
  // 2.1 完成支付（从钱包扣款）
  final result = await cardFeeService.completePayment(
    transactionRef: transactionRef,
    paymentCurrency: selectedCurrency,
  );

  if (result.status == 'completed') {
    // 2.2 支付成功，检查 KYC 资格
    final eligibility = await kycService.checkEligibility();

    if (eligibility.eligible) {
      // 2.3 跳转到 KYC 填资料页面
      Navigator.push(...);
    }
  } else {
    // 支付失败提示
    showError('支付失败');
  }
}
```

---

### 5️⃣ KYC 资格检查

#### 现有实现（`kyc_service.dart`）

```dart
// 调用的是旧的 KYC API
baseUrl: 'http://31.97.222.142:2050/api'

// getUserKyc 方法
GET /kyc?page=1&limit=10&email=xxx
```

**⚠️ 问题**：

- 这个接口查询的是 KYC 记录列表
- 不检查用户是否已支付开卡费
- 无法判断用户是否有资格申请

---

#### 新接口要求

```
GET http://149.88.65.193:8010/api/v1/kyc/eligibility

返回示例：
{
  "eligible": false,
  "payment_status": "none",  // none | completed
  "reason": "Card fee payment required before KYC verification",
  "required_action": "create_payment",
  "status": "success"
}
```

**✅ 逻辑**：

- `eligible = true` → 可以进行 KYC
- `eligible = false` + `payment_status = "none"` → 需要先支付
- `eligible = false` + `required_action = "create_payment"` → 引导用户去支付页面

**🔧 需要实现**：

1. 在 `KycService` 中添加 `checkEligibility()` 方法
2. 在进入 KYC 页面前调用此接口
3. 如果未支付，引导用户去支付页面

---

## 🆚 接口基础 URL 不一致

### 现有实现

| 模块 | Base URL                        | 端口 |
| ---- | ------------------------------- | ---- |
| KYC  | `http://31.97.222.142:2050/api` | 2050 |
| 其他 | 未明确，从 `BaseService` 继承   | ?    |

### 新接口

| 模块       | Base URL                    | 端口 |
| ---------- | --------------------------- | ---- |
| 所有新接口 | `http://149.88.65.193:8010` | 8010 |

**⚠️ 注意**：

- 新的开卡费接口基础 URL 是 `http://149.88.65.193:8010`
- 与现有的 KYC 接口不同服务器
- 需要确认项目是否要迁移到新服务器

---

## 📝 数据模型缺失

### 需要新建的 Model

#### 1. 开卡费配置 Model

```dart
class CardFeeConfigModel {
  final int id;
  final String cardType;      // virtual | physical
  final String feeType;       // flat
  final double feeAmount;
  final bool isActive;
  final String description;
  // ...
}
```

#### 2. 支付币种 Model

```dart
class PaymentCurrencyModel {
  final String name;          // "USDT-TRC20"
  final String symbol;        // "USDT"
  final String coinName;      // "TRC20-USDT"
  final String logo;
}
```

#### 3. 支付订单 Model

```dart
class CardFeePaymentModel {
  final int id;
  final int userId;
  final String cardType;
  final double originalFee;
  final double couponDiscount;
  final double actualPayment;
  final String status;        // pending | completed
  final String transactionRef;
  final String? paymentMethod;
  final String? couponCode;
  final String? couponName;
  // ...
}
```

#### 4. KYC 资格 Model

```dart
class KycEligibilityModel {
  final bool eligible;
  final String paymentStatus;     // none | completed
  final String reason;
  final String requiredAction;    // create_payment
}
```

---

## 🛠️ 需要新建的 Service 方法

### CardFeeService

```dart
class CardFeeService extends BaseService {
  @override
  String get baseUrl => 'http://149.88.65.193:8010';

  // 1. 获取开卡费配置
  Future<CardFeeConfigModel> getConfig(String cardType);

  // 2. 获取支付币种列表
  Future<List<PaymentCurrencyModel>> getCurrencies();

  // 3. 创建支付订单
  Future<CardFeePaymentModel> createPayment({
    required String cardType,
    String? couponCode,
  });

  // 4. 完成支付
  Future<CardFeePaymentModel> completePayment({
    required String transactionRef,
    required String paymentCurrency,
  });

  // 5. 查询支付状态
  Future<CardFeePaymentModel?> getPaymentStatus();

  // 6. 查询支付历史
  Future<List<CardFeePaymentModel>> getPaymentHistory({
    required int page,
    required int pageSize,
  });
}
```

### KycService 新增方法

```dart
// 在现有 KycService 中添加
Future<KycEligibilityModel> checkEligibility();
```

---

## 📋 完整的重构建议流程

### 阶段 1：基础准备（不改现有逻辑）

1. ✅ 创建数据模型（4 个）
2. ✅ 创建 `CardFeeService` 及其方法
3. ✅ 在 `KycService` 添加 `checkEligibility()` 方法
4. ✅ 注册 Service 到依赖注入

### 阶段 2：UI 改造

1. ✅ 改造 `CardApplyScreen`
   - 调用 API 获取开卡费，替代硬编码
   - 实现优惠券选择弹窗
2. ✅ 改造 `CardApplyConfirmScreen`
   - 调用 API 获取支付币种列表
   - 显示用户余额
   - 显示实际支付金额（应用优惠券后）

### 阶段 3：支付流程实现

1. ✅ 点击提交时创建支付订单
2. ✅ 弹出支付确认弹窗
3. ✅ 调用完成支付接口
4. ✅ 处理支付成功/失败

### 阶段 4：KYC 入口改造

1. ✅ 在进入 KYC 前调用资格检查
2. ✅ 未支付时引导去支付
3. ✅ 已支付才能进入 KYC 流程

---

## ⚡ 关键不匹配点总结

| 序号 | 问题                         | 影响                           | 优先级 |
| ---- | ---------------------------- | ------------------------------ | ------ |
| 1    | **开卡费硬编码**，未调用 API | 无法动态调整费用，运营不灵活   | 🔴 高  |
| 2    | **缺失整个支付流程**         | 用户无法真正支付开卡费         | 🔴 高  |
| 3    | **优惠券无法使用**           | 用户无法享受优惠，影响转化     | 🟡 中  |
| 4    | **支付币种选择混淆**         | 用户体验差，代码逻辑不清晰     | 🟡 中  |
| 5    | **KYC 资格检查缺失**         | 未支付也能进 KYC，业务逻辑错误 | 🔴 高  |
| 6    | **没有支付记录查询**         | 用户无法查看支付历史           | 🟢 低  |

---

## 🎯 总结

**现有开卡逻辑的核心问题**：

1. **跳过了支付环节** - 从选择网络直接跳到 KYC，中间缺失整个支付流程
2. **数据全部硬编码** - 开卡费、卡信息都是写死的，无法动态配置
3. **优惠券系统孤立** - 虽然有优惠券功能，但没有与开卡流程集成
4. **没有资格验证** - 不检查用户是否已支付就允许进入 KYC

**新接口的设计优势**：

1. ✅ 完整的支付生命周期管理
2. ✅ 支持优惠券降低获客成本
3. ✅ 多币种支付，用户体验好
4. ✅ 严格的资格验证，业务逻辑清晰
5. ✅ 完整的支付记录可追溯

**建议**：需要对开卡流程进行**完整重构**，而不是简单的接口适配。

---

_分析完成时间：2025-12-24_
